# -*- coding: utf-8 -*-
"""ANN-Multiclass.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U2Ix-PWtvWHxVD87Idul_yQl9--__aTm
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import scipy.io
from sklearn.model_selection import train_test_split
from scipy.io import loadmat
import matplotlib.pyplot as plt
import random
import math
import torch
import tensorflow as tf
from torch import nn
from torch.utils.data import DataLoader
from torchvision import datasets, transforms
from tqdm import tqdm
from torch import optim 
from sklearn.metrics import accuracy_score ,  confusion_matrix , ConfusionMatrixDisplay , roc_auc_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.utils import to_categorical

data_x = loadmat('/content/Thyroid_feature_space.mat')
data_y = loadmat('/content/Thyroid_labels.mat')

data_x = data_x['Thyroid_combined_feature_space']
data_y = data_y['Thyroid_target']
np.unique(data_y)

print(data_x.shape,data_y.shape)

train_x ,  test_x , train_y , test_y = train_test_split(data_x,data_y ,train_size = 0.7, shuffle= True)

test_1 = test_y
print(train_x.shape,train_y.shape,test_x.shape,test_y.shape)
train_y = to_categorical(train_y)
test_y = to_categorical(test_y)
print(train_x.shape,train_y.shape,test_x.shape,test_y.shape)

train_y = train_y[:,1:]
test_y = test_y[:,1:]

# train_x =  torch.from_numpy(train_x).float()
# test_x =  torch.from_numpy(test_x).float()
# train_y =  torch.from_numpy(train_y).float()
# test_y =  torch.from_numpy(test_y).float()

model=Sequential()

model.add(Dense(512, activation='relu',input_shape=[29,]))
model.add(Dense(512, activation='relu',input_shape=[512,]))
model.add(Dense(512, activation='relu',input_shape=[512,]))
model.add(Dense(3, activation='softmax'))

model.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])

# model = NeuralNetwork()
# num_epochs = 20
# loss_function = nn.BCELoss()
# learning_rate = 0.001
# optimizer = optim.Adam(model.parameters(), lr=learning_rate)
model.fit(x=train_x,y = train_y,validation_data=(test_x,test_y),epochs=50)

loss_df=pd.DataFrame(model.history.history)
loss_df.plot(figsize=(14,8))

predictions=np.argmax(model.predict(test_x), axis=-1)
# predictions = model.predict_proba(test_x)
predictions

model.evaluate(test_x,test_y,verbose=0)

cm_rbf = confusion_matrix(test_1, predictions)
disp_rbf = ConfusionMatrixDisplay(cm_rbf)
disp_rbf.plot()
plt.show()

def perf_measure(y_actual, y_pred):
    TP = 0
    FP = 0
    TN = 0
    FN = 0

    for i in range(len(y_pred)): 
        if y_actual[i]==y_pred[i]==1:
           TP += 1
        if y_pred[i]==1 and y_actual[i]!=y_pred[i]:
           FP += 1
        if y_actual[i]==y_pred[i]==0:
           TN += 1
        if y_pred[i]==0 and y_actual[i]!=y_pred[i]:
           FN += 1

    return(TP, FP, TN, FN)

perf_measure(test_1,predictions)

specificity  =  5 / (5 + 55)
specificity  = specificity*10

sensitivity = 6 / 111
sensitivity = sensitivity*10

